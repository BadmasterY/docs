`Deno` 在运行时同时支持 `JavaScript` 和 `TypeScript` 作为一级语言。这意味着它需要完全限定的模块名，包括扩展名(或提供正确媒体类型的服务器)。此外, `Deno` 没有"神奇"的模块解析器。相反, 导入的模块被指定为文件(包括扩展名)或完全限定的 `URL` 导入。可以直接导入 `Typescript` 模块。例如:
```ts
import { Response } from "https://deno.land/std@0.53.0/http/server.ts";
import { queue } from "./collections.ts";
```

### 使用外部类型定义
不过, 开箱即用的 `TypeScript` 编译器依赖于无扩展名(`extension-less`)模块和 `Node.js` 模块解析逻辑来将类型应用于 `JavaScript` 模块。

为了弥补这一差距, `Deno` 支持三种引用类型定义文件的方式, 而不必使用"神奇"解析。

#### 编译提示
如果要导入 `JavaScript` 模块, 并且知道该模块的类型定义位于何处, 则可以在导入时指定类型定义。这采用编译器提示的形式。编译器提示会告知 `Deno` `.d.ts` 文件的位置以及与它们相关的导入的 `JavaScript` 代码。编译提示是 `@deno-types`, 当指定时, 该值将在编译器中使用, 而不是 `JavaScript` 模块中。例如, 如果您有 `foo.js`, 但您知道它旁边有名为 `foo.d.ts` 的类型文件, 则代码将如下所示:
```ts
// @deno-types="./foo.d.ts"
import * as foo from "./foo.js";
```

该值遵循与导入模块相同的解析逻辑, 这意味着该文件需要具有扩展名, 并且相对于当前模块。也允许使用远程说明符。

该提示会影响下一条 `import` 语句(或 `export...from` 语句), 在该语句中, `@deno-types` 的值将在编译时取代指定的模块的值。像上面的示例一样, `Deno` 编译器将加载 `./foo.d.ts` 代替 `./foo.js`。但是 `Deno` 在运行程序时仍会加载 `./foo.js`。

#### Javascript 文件中的三重斜杠引用指令
如果您托管的模块希望被 `Deno` 使用, 并且要通知 `Deno` 类型定义的位置, 则可以在实际代码中使用三斜杠指令。例如, 如果您有一个 `JavaScript` 模块, 并且您希望向 `Deno` 提供恰好位于该文件同级目录的类型定义的位置